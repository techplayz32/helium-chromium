--- /dev/null
+++ b/chrome/browser/importer/chrome_importer_list.cc
@@ -0,0 +1,130 @@
+/* Copyright (c) 2019 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/importer_list.h"
+#include "base/files/file_path.h"
+#include "base/strings/strcat.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/values.h"
+#include "chrome/common/importer/chrome_importer_utils.h"
+#include "chrome/common/importer/importer_constants.h"
+#include "chrome/common/importer/importer_type.h"
+#include "chrome/grit/generated_resources.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace {
+void AddChromeToProfiles(std::vector<importer::SourceProfile>* profiles,
+                         base::Value::List chrome_profiles,
+                         const base::FilePath& user_data_folder,
+                         const std::string& brand,
+                         importer::ImporterType type) {
+  for (const auto& value : chrome_profiles) {
+    const auto* dict = value.GetIfDict();
+    if (!dict)
+      continue;
+    uint16_t items = importer::NONE;
+    auto* profile = dict->FindString("id");
+    auto* name = dict->FindString("name");
+    DCHECK(profile);
+    DCHECK(name);
+    base::FilePath path = user_data_folder;
+    if (!ChromeImporterCanImport(path.Append(base::FilePath::StringType(
+                                     profile->begin(), profile->end())),
+                                 &items))
+      continue;
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
+    // We can import password from Whale only on macOS.
+    // Decryption failed on Windows and Linux.
+    if (type == importer::TYPE_WHALE && (items & importer::PASSWORDS)) {
+      items ^= importer::PASSWORDS;
+    }
+#endif
+    importer::SourceProfile chrome;
+    chrome.importer_name = base::UTF8ToUTF16(base::StrCat({brand, " ", *name}));
+    chrome.importer_type = type;
+    chrome.services_supported = items;
+    chrome.source_path = user_data_folder.Append(
+        base::FilePath::StringType(profile->begin(), profile->end()));
+    profiles->push_back(chrome);
+  }
+}
+
+void DetectChromeProfiles(std::vector<importer::SourceProfile>* profiles) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::WILL_BLOCK);
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetChromeUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetChromeUserDataFolder(), kGoogleChromeBrowser, importer::TYPE_CHROME);
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetChromeBetaUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetChromeBetaUserDataFolder(), kGoogleChromeBrowserBeta,
+      importer::TYPE_CHROME);
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetChromeDevUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetChromeDevUserDataFolder(), kGoogleChromeBrowserDev,
+      importer::TYPE_CHROME);
+#if !BUILDFLAG(IS_LINUX)
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetCanaryUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetCanaryUserDataFolder(), kGoogleChromeBrowserCanary,
+      importer::TYPE_CHROME);
+#endif
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetChromiumUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetChromiumUserDataFolder(), kChromiumBrowser, importer::TYPE_CHROME);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetEdgeUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetEdgeUserDataFolder(), kMicrosoftEdgeBrowser,
+      importer::TYPE_EDGE_CHROMIUM);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetVivaldiUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetVivaldiUserDataFolder(), kVivaldiBrowser, importer::TYPE_VIVALDI);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetOperaUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetOperaUserDataFolder(), kOperaBrowser, importer::TYPE_OPERA);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetYandexUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetYandexUserDataFolder(), kYandexBrowser, importer::TYPE_YANDEX);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetWhaleUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetWhaleUserDataFolder(), kWhaleBrowser, importer::TYPE_WHALE);
+
+#if BUILDFLAG(IS_LINUX)
+  // Installed via snap Opera has different profile path.
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetOperaSnapUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetOperaSnapUserDataFolder(), kOperaBrowser, importer::TYPE_OPERA);
+#endif
+}
+
+}  // namespace
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils.cc
@@ -0,0 +1,216 @@
+/* Copyright (c) 2019 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include "chrome/common/importer/chrome_importer_utils.h"
+
+#include <memory>
+#include <optional>
+#include <utility>
+
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/json/json_reader.h"
+#include "base/values.h"
+#include "chrome/common/importer/importer_constants.h"
+#include "chrome/common/importer/scoped_copy_file.h"
+#include "chrome/common/importer/importer_data_types.h"
+#include "components/webdata/common/webdata_constants.h"
+#include "sql/database.h"
+#include "sql/statement.h"
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+#include "extensions/common/extension.h"
+#include "extensions/common/manifest.h"
+#endif
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+using extensions::Extension;
+using extensions::Manifest;
+#endif
+
+namespace {
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+
+std::optional<base::Value::Dict> GetChromeExtensionsListFromFile(
+    const base::FilePath& preference_path) {
+  if (!base::PathExists(preference_path))
+    return std::nullopt;
+
+  std::string preference_content;
+  base::ReadFileToString(preference_path, &preference_content);
+
+  std::optional<base::Value::Dict> preference =
+      base::JSONReader::ReadDict(preference_content);
+  if (!preference) {
+    return std::nullopt;
+  }
+  if (auto* extensions =
+          preference->FindDictByDottedPath(kChromeExtensionsListPath)) {
+    return std::move(*extensions);
+  }
+  return std::nullopt;
+}
+
+bool HasImportableExtensions(const base::FilePath& profile_path) {
+  return GetImportableChromeExtensionsList(profile_path).has_value();
+}
+
+std::vector<std::string> GetImportableListFromChromeExtensionsList(
+    const base::Value::Dict& extensions_list) {
+  std::vector<std::string> extensions;
+  for (const auto [key, value] : extensions_list) {
+    if (!value.is_dict()) {
+      continue;
+    }
+    const base::Value::Dict& dict = value.GetDict();
+    // Only import if type is extension, it's came from webstore and it's not
+    // installed by default.
+    if (dict.FindBool("was_installed_by_default").value_or(true))
+      continue;
+
+    // `"state": 0` means disabled state
+    if (!dict.FindInt("state").value_or(false))
+      continue;
+
+    if (!dict.FindBool("from_webstore").value_or(false))
+      continue;
+
+    if (auto* manifest_dict = dict.FindDict("manifest")) {
+      if (Manifest::GetTypeFromManifestValue(*manifest_dict) ==
+          Manifest::TYPE_EXTENSION) {
+        extensions.push_back(key);
+      }
+    }
+  }
+
+  return extensions;
+}
+
+std::optional<base::Value::Dict> GetChromeExtensionsList(
+    const base::FilePath& profile_path) {
+  auto list_from_secure_preference = GetChromeExtensionsListFromFile(
+      profile_path.AppendASCII(kChromeSecurePreferencesFile));
+
+  auto list_from_preferences = GetChromeExtensionsListFromFile(
+      profile_path.AppendASCII(kChromePreferencesFile));
+  if (!list_from_secure_preference.has_value())
+    return list_from_preferences;
+
+  if (list_from_secure_preference.has_value() &&
+      list_from_preferences.has_value()) {
+    list_from_secure_preference->Merge(
+        std::move(list_from_preferences.value()));
+    return list_from_secure_preference;
+  }
+
+  return list_from_secure_preference;
+}
+#endif
+
+bool IsLastActiveProfile(const std::string& profile,
+                         const base::Value::List& last_active_profiles) {
+  for (const auto& it : last_active_profiles) {
+    if (it.GetString() == profile) {
+      return true;
+    }
+  }
+  return false;
+}
+
+}  // namespace
+
+base::Value::List GetChromeSourceProfiles(
+    const base::FilePath& local_state_path) {
+  base::Value::List profiles;
+  if (base::PathExists(local_state_path)) {
+    std::string local_state_content;
+    base::ReadFileToString(local_state_path, &local_state_content);
+    std::optional<base::Value::Dict> local_state_dict =
+        base::JSONReader::ReadDict(local_state_content);
+    if (!local_state_dict)
+      return profiles;
+
+    const auto* profile_dict = local_state_dict->FindDict("profile");
+    if (profile_dict) {
+      const auto* last_active_profiles =
+          profile_dict->FindList("last_active_profiles");
+
+      const auto* info_cache = profile_dict->FindDict("info_cache");
+      if (info_cache) {
+        for (const auto value : *info_cache) {
+          const auto* profile = value.second.GetIfDict();
+          if (!profile)
+            continue;
+
+          auto* name = profile->FindString("name");
+          if (!name) {
+            continue;
+          }
+          base::Value::Dict entry;
+          entry.Set("id", value.first);
+          entry.Set("name", *name);
+          if (last_active_profiles)
+            entry.Set("last_active",
+                      IsLastActiveProfile(value.first, *last_active_profiles));
+
+          auto* avatar_icon = profile->FindString("avatar_icon");
+          if (avatar_icon) {
+            entry.Set("avatar_icon", *avatar_icon);
+          }
+          auto active_time = profile->FindDouble("active_time");
+          if (active_time) {
+            entry.Set("active_time", *active_time);
+          }
+          profiles.Append(std::move(entry));
+        }
+      }
+    }
+  }
+  if (profiles.empty()) {
+    base::Value::Dict entry;
+    entry.Set("id", "");
+    entry.Set("name", "Default");
+    profiles.Append(std::move(entry));
+  }
+  return profiles;
+}
+
+bool ChromeImporterCanImport(const base::FilePath& profile,
+                             uint16_t* services_supported) {
+  DCHECK(services_supported);
+  *services_supported = importer::NONE;
+
+  base::FilePath bookmarks =
+    profile.Append(base::FilePath::StringType(FILE_PATH_LITERAL("Bookmarks")));
+  base::FilePath history =
+    profile.Append(base::FilePath::StringType(FILE_PATH_LITERAL("History")));
+  base::FilePath passwords = profile.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("Login Data")));
+  base::FilePath passwords_for_account = profile.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("Login Data For Account")));
+  if (base::PathExists(bookmarks))
+    *services_supported |= importer::FAVORITES;
+  if (base::PathExists(history))
+    *services_supported |= importer::HISTORY;
+  if (base::PathExists(passwords) || base::PathExists(passwords_for_account)) {
+    *services_supported |= importer::PASSWORDS;
+  }
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (HasImportableExtensions(profile))
+    *services_supported |= importer::EXTENSIONS;
+#endif
+
+  return *services_supported != importer::NONE;
+}
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+std::optional<std::vector<std::string>> GetImportableChromeExtensionsList(
+    const base::FilePath& profile_path) {
+  if (auto extensions = GetChromeExtensionsList(profile_path)) {
+    return GetImportableListFromChromeExtensionsList(extensions.value());
+  }
+  return std::nullopt;
+}
+#endif
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils.h
@@ -0,0 +1,51 @@
+/* Copyright (c) 2019 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_COMMON_IMPORTER_CHROME_IMPORTER_UTILS_H_
+#define BRAVE_COMMON_IMPORTER_CHROME_IMPORTER_UTILS_H_
+
+#include <optional>
+#include <string>
+#include <vector>
+
+#include "base/values.h"
+#include "build/build_config.h"
+#include "extensions/buildflags/buildflags.h"
+
+namespace base {
+class FilePath;
+}  // namespace base
+
+// Chrome / Chromium paths
+// https://chromium.googlesource.com/chromium/src/+/HEAD/docs/user_data_dir.md
+base::FilePath GetChromeUserDataFolder();
+base::FilePath GetChromeBetaUserDataFolder();
+base::FilePath GetChromeDevUserDataFolder();
+#if !BUILDFLAG(IS_LINUX)
+// Canary is not available on Linux
+base::FilePath GetCanaryUserDataFolder();
+#endif
+base::FilePath GetChromiumUserDataFolder();
+
+base::FilePath GetEdgeUserDataFolder();
+
+base::FilePath GetVivaldiUserDataFolder();
+base::FilePath GetOperaUserDataFolder();
+base::FilePath GetYandexUserDataFolder();
+base::FilePath GetWhaleUserDataFolder();
+
+#if BUILDFLAG(IS_LINUX)
+base::FilePath GetOperaSnapUserDataFolder();
+#endif
+base::Value::List GetChromeSourceProfiles(const base::FilePath& local_state);
+bool ChromeImporterCanImport(const base::FilePath& profile,
+                             uint16_t* services_supported);
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+std::optional<std::vector<std::string>> GetImportableChromeExtensionsList(
+    const base::FilePath& profile_path);
+#endif
+
+#endif  // BRAVE_COMMON_IMPORTER_CHROME_IMPORTER_UTILS_H_
--- /dev/null
+++ b/chrome/common/importer/importer_constants.h
@@ -0,0 +1,34 @@
+/* Copyright (c) 2020 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_COMMON_IMPORTER_IMPORTER_CONSTANTS_H_
+#define BRAVE_COMMON_IMPORTER_IMPORTER_CONSTANTS_H_
+
+#include "build/build_config.h"
+
+// Prefs files that holds installed extension list.
+inline constexpr char kChromeSecurePreferencesFile[] = "Secure Preferences";
+inline constexpr char kChromePreferencesFile[] = "Preferences";
+
+inline constexpr char kChromeExtensionsListPath[] = "extensions.settings";
+inline constexpr char kChromeLocalStateFile[] = "Local State";
+
+// Browser names section, the names mostly match the identifier that is used to
+// identify the default browser, if you change these constants(or adding a new
+// one) make sure that brave://welcome page will identify this browser as the
+// default one
+inline constexpr char kGoogleChromeBrowser[] = "Google Chrome";
+inline constexpr char kGoogleChromeBrowserBeta[] = "Google Chrome Beta";
+inline constexpr char kGoogleChromeBrowserDev[] = "Google Chrome Dev";
+inline constexpr char kGoogleChromeBrowserCanary[] = "Google Chrome Canary";
+inline constexpr char kChromiumBrowser[] = "Chromium";
+inline constexpr char kMicrosoftEdgeBrowser[] = "Microsoft Edge";
+inline constexpr char kVivaldiBrowser[] = "Vivaldi";
+inline constexpr char kOperaBrowser[] = "Opera";
+inline constexpr char kYandexBrowser[] = "Yandex";
+inline constexpr char kWhaleBrowser[] = "NAVER Whale";
+// End of browser names section
+
+#endif  // BRAVE_COMMON_IMPORTER_IMPORTER_CONSTANTS_H_
--- /dev/null
+++ b/chrome/common/importer/scoped_copy_file.cc
@@ -0,0 +1,20 @@
+/* Copyright 2020 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/common/importer/scoped_copy_file.h"
+
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+
+ScopedCopyFile::ScopedCopyFile(const base::FilePath& original_file_path) {
+  DCHECK(base::PathExists(original_file_path));
+  if (base::CreateTemporaryFile(&copied_file_path_))
+    copy_success_ = base::CopyFile(original_file_path, copied_file_path_);
+}
+
+ScopedCopyFile::~ScopedCopyFile() {
+  if (base::PathExists(copied_file_path_))
+    base::DeleteFile(copied_file_path_);
+}
--- /dev/null
+++ b/chrome/common/importer/scoped_copy_file.h
@@ -0,0 +1,27 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_COMMON_IMPORTER_SCOPED_COPY_FILE_H_
+#define BRAVE_COMMON_IMPORTER_SCOPED_COPY_FILE_H_
+
+#include "base/files/file_path.h"
+
+class ScopedCopyFile {
+ public:
+  explicit ScopedCopyFile(const base::FilePath& original_file_path);
+  ~ScopedCopyFile();
+
+  ScopedCopyFile(const ScopedCopyFile&) = delete;
+  ScopedCopyFile& operator=(const ScopedCopyFile&) = delete;
+
+  bool copy_success() const { return copy_success_; }
+  base::FilePath copied_file_path() const { return copied_file_path_; }
+
+ private:
+  bool copy_success_ = false;
+  base::FilePath copied_file_path_;
+};
+
+#endif  // BRAVE_COMMON_IMPORTER_SCOPED_COPY_FILE_H_
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils_linux.cc
@@ -0,0 +1,121 @@
+/* Copyright (c) 2018 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/common/importer/chrome_importer_utils.h"
+
+#include "base/base_paths.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/path_service.h"
+
+base::FilePath GetChromeUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("google-chrome");
+
+  return result;
+}
+
+base::FilePath GetChromeBetaUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("google-chrome-beta");
+
+  return result;
+}
+
+base::FilePath GetChromeDevUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("google-chrome-unstable");
+
+  return result;
+}
+
+base::FilePath GetVivaldiUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  return result.Append(".config").Append("vivaldi");
+}
+
+base::FilePath GetChromiumUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("chromium");
+
+  return result;
+}
+
+base::FilePath GetEdgeUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("microsoft-edge");
+
+  return result;
+}
+
+base::FilePath GetOperaUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("opera");
+
+  return result;
+}
+
+base::FilePath GetOperaSnapUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append("snap");
+  result = result.Append("opera");
+  result = result.Append("current");
+  result = result.Append(".config");
+  result = result.Append("opera");
+
+  return result;
+}
+
+base::FilePath GetYandexUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("yandex-browser");
+
+  return result;
+}
+
+base::FilePath GetWhaleUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("naver-whale");
+
+  return result;
+}
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils_mac.mm
@@ -0,0 +1,62 @@
+/* Copyright (c) 2018 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include <Cocoa/Cocoa.h>
+#include <sys/param.h>
+
+#include "chrome/common/importer/chrome_importer_utils.h"
+
+#include "base/apple/foundation_util.h"
+#include "base/files/file_util.h"
+
+base::FilePath GetChromeUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Google/Chrome");
+}
+
+base::FilePath GetChromeBetaUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Google/Chrome Beta");
+}
+
+base::FilePath GetChromeDevUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Google/Chrome Dev");
+}
+
+base::FilePath GetCanaryUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Google/Chrome Canary");
+}
+
+base::FilePath GetVivaldiUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Vivaldi");
+}
+
+base::FilePath GetChromiumUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Chromium");
+}
+
+base::FilePath GetEdgeUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Microsoft Edge");
+}
+
+base::FilePath GetOperaUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/com.operasoftware.Opera");
+}
+
+base::FilePath GetYandexUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Yandex/YandexBrowser");
+}
+
+base::FilePath GetWhaleUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support").Append("Naver").Append("Whale");
+}
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils_win.cc
@@ -0,0 +1,123 @@
+/* Copyright (c) 2021 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/common/importer/chrome_importer_utils.h"
+
+#include "base/files/file_util.h"
+#include "base/path_service.h"
+
+base::FilePath GetChromeUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Google");
+  result = result.AppendASCII("Chrome");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetChromeBetaUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Google");
+  result = result.AppendASCII("Chrome Beta");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetChromeDevUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Google");
+  result = result.AppendASCII("Chrome Dev");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetCanaryUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Google");
+  result = result.AppendASCII("Chrome SxS");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetVivaldiUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Vivaldi");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetChromiumUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Chromium");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetEdgeUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Microsoft");
+  result = result.AppendASCII("Edge");
+  result = result.AppendASCII("User Data");
+  return result;
+}
+
+base::FilePath GetOperaUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_ROAMING_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Opera Software");
+  result = result.AppendASCII("Opera Stable");
+
+  return result;
+}
+
+base::FilePath GetYandexUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Yandex");
+  result = result.AppendASCII("YandexBrowser");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetWhaleUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  return result.AppendASCII("Naver")
+      .AppendASCII("Naver Whale")
+      .AppendASCII("User Data");
+}
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_import_data_handler.cc
@@ -0,0 +1,198 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/ui/webui/settings/brave_import_data_handler.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "chrome/browser/importer/brave_external_process_importer_host.h"
+#include "chrome/browser/importer/importer_list.h"
+#include "chrome/browser/importer/profile_writer.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/web_contents.h"
+
+#if BUILDFLAG(IS_MAC)
+#include "base/apple/foundation_util.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/task/thread_pool.h"
+#include "chrome/browser/ui/webui/settings/brave_full_disk_access_confirm_dialog_delegate.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/tab_modal_confirm_dialog.h"
+#endif  // BUILDFLAG(IS_MAC)
+
+namespace {
+#if BUILDFLAG(IS_MAC)
+bool HasProperDiskAccessPermission(uint16_t imported_items) {
+  DCHECK(imported_items);
+
+  const base::FilePath& library_dir = base::apple::GetUserLibraryPath();
+  const base::FilePath safari_dir = library_dir.Append("Safari");
+
+  if (imported_items & importer::FAVORITES) {
+    const base::FilePath bookmarks_path = safari_dir.Append("Bookmarks.plist");
+    if (!PathIsWritable(bookmarks_path)) {
+      LOG(ERROR) << __func__ << " " << bookmarks_path << " is not accessible."
+                 << " Please check full disk access permission.";
+      return false;
+    }
+  }
+
+  if (imported_items & importer::HISTORY) {
+    const base::FilePath history_path = safari_dir.Append("History.plist");
+    if (!PathIsWritable(history_path)) {
+      LOG(ERROR) << __func__ << " " << history_path << " is not accessible."
+                 << " Please check full disk access permission.";
+      return false;
+    }
+  }
+
+  return true;
+}
+#endif  // BUILDFLAG(IS_MAC)
+constexpr char kImportStatusSucceeded[] = "succeeded";
+constexpr char kImportStatusFailed[] = "failed";
+}  // namespace
+
+namespace settings {
+
+BraveImportDataHandler::BraveImportDataHandler() = default;
+BraveImportDataHandler::~BraveImportDataHandler() = default;
+
+void BraveImportDataHandler::StartImport(
+    const importer::SourceProfile& source_profile,
+    uint16_t imported_items) {
+  if (!imported_items)
+    return;
+  Profile* profile = Profile::FromWebUI(web_ui());
+#if BUILDFLAG(IS_MAC)
+  CheckDiskAccess(imported_items, source_profile.source_path,
+                  source_profile.importer_type,
+                  base::BindOnce(&BraveImportDataHandler::StartImportImpl,
+                                 weak_factory_.GetWeakPtr(), source_profile,
+                                 imported_items, profile));
+#else
+  StartImportImpl(source_profile, imported_items, profile);
+#endif
+}
+
+void BraveImportDataHandler::StartImportImpl(
+    const importer::SourceProfile& source_profile,
+    uint16_t imported_items,
+    Profile* profile) {
+  // If another import is already ongoing, let it finish silently.
+  if (import_observers_.count(source_profile.source_path))
+    import_observers_.erase(source_profile.source_path);
+
+  // Using weak pointers because it destroys itself when finshed.
+  auto* importer_host = new BraveExternalProcessImporterHost();
+  import_observers_[source_profile.source_path] =
+      std::make_unique<BraveImporterObserver>(
+          importer_host, source_profile, imported_items,
+          base::BindRepeating(&BraveImportDataHandler::NotifyImportProgress,
+                              weak_factory_.GetWeakPtr()));
+
+  importer_host->StartImportSettings(source_profile, profile, imported_items,
+                                     new ProfileWriter(profile));
+}
+
+void BraveImportDataHandler::NotifyImportProgress(
+    const importer::SourceProfile& source_profile,
+    const base::Value::Dict& info) {
+  const std::string* event = info.FindString("event");
+  if (!event)
+    return;
+  if (*event == "ImportItemEnded") {
+    import_did_succeed_ = true;
+  } else if (*event == "ImportEnded") {
+    content::GetUIThreadTaskRunner({})->PostTask(
+        FROM_HERE, base::BindOnce(&BraveImportDataHandler::OnImportEnded,
+                                  weak_factory_.GetWeakPtr(), source_profile));
+  }
+}
+
+void BraveImportDataHandler::HandleImportData(const base::Value::List& args) {
+  ImportDataHandler::HandleImportData(args);
+}
+
+void BraveImportDataHandler::OnImportEnded(
+    const importer::SourceProfile& source_profile) {
+  import_observers_.erase(source_profile.source_path);
+  FireWebUIListener("import-data-status-changed",
+                    base::Value(import_did_succeed_ ? kImportStatusSucceeded
+                                                    : kImportStatusFailed));
+}
+
+const importer::SourceProfile& BraveImportDataHandler::GetSourceProfileAt(
+    int browser_index) {
+  return importer_list_->GetSourceProfileAt(browser_index);
+}
+
+#if BUILDFLAG(IS_MAC)
+void BraveImportDataHandler::CheckDiskAccess(
+    uint16_t imported_items,
+    base::FilePath source_path,
+    importer::ImporterType importer_type,
+    ContinueImportCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  guide_dialog_is_requested_ = false;
+
+  if (importer_type == importer::TYPE_SAFARI) {
+    // Start import if Brave has full disk access permission.
+    // If not, show dialog that has infos about that permission.
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE, {base::MayBlock()},
+        base::BindOnce(&HasProperDiskAccessPermission, imported_items),
+        base::BindOnce(&BraveImportDataHandler::OnGetDiskAccessPermission,
+                       weak_factory_.GetWeakPtr(), std::move(callback),
+                       source_path));
+    return;
+  }
+  std::move(callback).Run();
+}
+
+void BraveImportDataHandler::OnGetDiskAccessPermission(
+    ContinueImportCallback callback,
+    base::FilePath source_path,
+    bool allowed) {
+  if (!allowed) {
+    // Notify to webui to finish import process and launch tab modal dialog
+    // to guide full disk access information to users.
+    // Guide dialog will be opened after import dialog is closed.
+    FireWebUIListener("import-data-status-changed", base::Value("failed"));
+    if (import_observers_.count(source_path))
+      import_observers_[source_path]->ImportEnded();
+    // Observing web_contents is started here to know the closing timing of
+    // import dialog.
+    Observe(web_ui()->GetWebContents());
+
+    guide_dialog_is_requested_ = true;
+    return;
+  }
+
+  std::move(callback).Run();
+}
+
+void BraveImportDataHandler::DidStopLoading() {
+  Observe(nullptr);
+
+  if (!guide_dialog_is_requested_)
+    return;
+
+  guide_dialog_is_requested_ = false;
+
+  auto* web_contents = web_ui()->GetWebContents();
+  TabModalConfirmDialog::Create(
+      std::make_unique<FullDiskAccessConfirmDialogDelegate>(
+          web_contents, chrome::FindBrowserWithTab(web_contents)),
+      web_contents);
+}
+#endif
+}  // namespace settings
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_import_data_handler.h
@@ -0,0 +1,82 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORT_DATA_HANDLER_H_
+#define BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORT_DATA_HANDLER_H_
+
+#include <memory>
+#include <unordered_map>
+
+#include "base/memory/weak_ptr.h"
+#include "chrome/browser/ui/webui/settings/brave_importer_observer.h"
+#include "build/build_config.h"
+#include "chrome/browser/ui/webui/settings/import_data_handler.h"
+#include "content/public/browser/web_contents_observer.h"
+
+namespace settings {
+
+// This class checks whether Brave has full disk access permission to import
+// safari data on macOS. ImportDataHandler::StartImport() will be run after
+// checking disk access permission. If Brave doesn't have that permission, this
+// will launch tab modal dialog to notify users about this lack of permission.
+
+// We should display tab modal dialog after import dialog is closed from webui.
+// To do that, this observes web contents to launch dialog after import dialog
+// closed. If dialog is launched right after notifying import failure,
+// dialog will be closed immediately because tab modal dialog is closed with
+// new navigation start and tab is newly loaded for closing webui import dialog.
+// The reason why native tab modal dialog is used here is to avoid modifying
+// upstream import html/js source code.
+class BraveImportDataHandler : public ImportDataHandler,
+                                      content::WebContentsObserver {
+ public:
+  BraveImportDataHandler();
+  ~BraveImportDataHandler() override;
+
+  BraveImportDataHandler(const BraveImportDataHandler&) = delete;
+  BraveImportDataHandler& operator=(const BraveImportDataHandler&) = delete;
+
+ protected:
+  using ContinueImportCallback = base::OnceCallback<void()>;
+
+  const importer::SourceProfile& GetSourceProfileAt(int browser_index);
+  void HandleImportData(const base::Value::List& args);
+  // ImportDataHandler overrides:
+  void StartImport(const importer::SourceProfile& source_profile,
+                   uint16_t imported_items) override;
+
+  void StartImportImpl(const importer::SourceProfile& source_profile,
+                       uint16_t imported_items,
+                       Profile* profile);
+  virtual void NotifyImportProgress(
+      const importer::SourceProfile& source_profile,
+      const base::Value::Dict& info);
+  virtual void OnImportEnded(const importer::SourceProfile& source_profile);
+
+  void OnStartImport(const importer::SourceProfile& source_profile,
+                     uint16_t imported_items);
+#if BUILDFLAG(IS_MAC)
+  void CheckDiskAccess(uint16_t imported_items,
+                       base::FilePath source_path,
+                       importer::ImporterType importer_type,
+                       ContinueImportCallback callback);
+  void OnGetDiskAccessPermission(ContinueImportCallback callback,
+                                 base::FilePath source_path,
+                                 bool allowed);
+
+  // content::WebContentsObserver overrides:
+  void DidStopLoading() override;
+
+  bool guide_dialog_is_requested_ = false;
+#endif
+ private:
+  std::unordered_map<base::FilePath, std::unique_ptr<BraveImporterObserver>>
+      import_observers_;
+  base::WeakPtrFactory<BraveImportDataHandler> weak_factory_{this};
+};
+
+}  // namespace settings
+
+#endif  // BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORT_DATA_HANDLER_H_
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_importer_observer.cc
@@ -0,0 +1,83 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/ui/webui/settings/brave_importer_observer.h"
+
+#include <utility>
+
+#include "base/logging.h"
+#include "chrome/browser/importer/external_process_importer_host.h"
+
+BraveImporterObserver::BraveImporterObserver(
+    ExternalProcessImporterHost* importer_host,
+    const importer::SourceProfile& source_profile,
+    uint16_t imported_items,
+    ReportProgressCallback callback)
+    : source_profile_(source_profile),
+      imported_items_(imported_items),
+      callback_(std::move(callback)),
+      importer_host_(importer_host) {
+  DCHECK(importer_host);
+  importer_host->set_observer(this);
+}
+
+BraveImporterObserver::~BraveImporterObserver() {
+  if (importer_host_)
+    importer_host_->set_observer(nullptr);
+}
+
+// importer::ImporterProgressObserver:
+void BraveImporterObserver::ImportStarted() {
+  if (import_started_called_)
+    return;
+  import_started_called_ = true;
+  base::Value::Dict data;
+  data.Set("importer_name", source_profile_.importer_name);
+  data.Set("importer_type", source_profile_.importer_type);
+  data.Set("items_to_import", imported_items_);
+  data.Set("event", "ImportStarted");
+  callback_.Run(source_profile_, data);
+}
+
+void BraveImporterObserver::ImportItemStarted(importer::ImportItem item) {
+  base::Value::Dict data;
+  data.Set("importer_name", source_profile_.importer_name);
+  data.Set("importer_type", source_profile_.importer_type);
+  data.Set("items_to_import", imported_items_);
+  data.Set("event", "ImportItemStarted");
+  data.Set("item", item);
+  callback_.Run(source_profile_, data);
+}
+
+void BraveImporterObserver::ImportItemEnded(importer::ImportItem item) {
+  base::Value::Dict data;
+  data.Set("importer_name", source_profile_.importer_name);
+  data.Set("importer_type", source_profile_.importer_type);
+  data.Set("items_to_import", imported_items_);
+  data.Set("event", "ImportItemEnded");
+  data.Set("item", item);
+  callback_.Run(source_profile_, data);
+}
+
+void BraveImporterObserver::ImportEnded() {
+  base::Value::Dict data;
+  data.Set("importer_name", source_profile_.importer_name);
+  data.Set("importer_type", source_profile_.importer_type);
+  data.Set("items_to_import", imported_items_);
+  data.Set("event", "ImportEnded");
+
+  DCHECK(importer_host_);
+  if (importer_host_)
+    importer_host_->set_observer(nullptr);
+
+  importer_host_ = nullptr;
+
+  callback_.Run(source_profile_, data);
+}
+
+ExternalProcessImporterHost*
+BraveImporterObserver::GetImporterHostForTesting() {
+  return importer_host_.get();
+}
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_importer_observer.h
@@ -0,0 +1,50 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORTER_OBSERVER_H_
+#define BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORTER_OBSERVER_H_
+
+#include "base/functional/callback.h"
+#include "base/gtest_prod_util.h"
+#include "base/memory/raw_ptr.h"
+#include "base/values.h"
+#include "chrome/browser/importer/importer_progress_observer.h"
+
+class ExternalProcessImporterHost;
+
+class BraveImporterObserver : public importer::ImporterProgressObserver {
+ public:
+  using ReportProgressCallback = base::RepeatingCallback<void(
+      const importer::SourceProfile& source_profile,
+      const base::Value::Dict&)>;
+
+  BraveImporterObserver(ExternalProcessImporterHost* host,
+                        const importer::SourceProfile& source_profile,
+                        uint16_t imported_items,
+                        ReportProgressCallback callback);
+  ~BraveImporterObserver() override;
+
+  void ImportStarted() override;
+  void ImportItemStarted(importer::ImportItem item) override;
+  void ImportItemEnded(importer::ImportItem item) override;
+  void ImportEnded() override;
+
+ private:
+  FRIEND_TEST_ALL_PREFIXES(BraveImporterObserverUnitTest, ImportEvents);
+
+  ExternalProcessImporterHost* GetImporterHostForTesting();
+
+  importer::SourceProfile source_profile_;
+  uint16_t imported_items_ = 0;
+  ReportProgressCallback callback_;
+  // By some reasons ImportStarted event is called few times from different
+  // places, we expect only one call.
+  bool import_started_called_ = false;
+  // If non-null it means importing is in progress. ImporterHost takes care
+  // of deleting itself when import is complete.
+  raw_ptr<ExternalProcessImporterHost> importer_host_;  // weak
+};
+
+#endif  // BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORTER_OBSERVER_H_
--- /dev/null
+++ b/chrome/browser/importer/brave_external_process_importer_client.cc
@@ -0,0 +1,108 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/brave_external_process_importer_client.h"
+
+#include <utility>
+
+#include "base/functional/bind.h"
+#include "chrome/browser/importer/brave_in_process_importer_bridge.h"
+#include "chrome/grit/generated_resources.h"
+#include "content/public/browser/service_process_host.h"
+
+namespace {
+bool ShouldUseBraveImporter(importer::ImporterType type) {
+  switch (type) {
+    case importer::TYPE_CHROME:
+    case importer::TYPE_EDGE_CHROMIUM:
+    case importer::TYPE_VIVALDI:
+    case importer::TYPE_OPERA:
+    case importer::TYPE_YANDEX:
+    case importer::TYPE_WHALE:
+      return true;
+    default:
+      return false;
+  }
+}
+}  // namespace
+
+template <>
+inline sandbox::mojom::Sandbox
+content::GetServiceSandboxType<chrome::mojom::ChromeProfileImport>() {
+  return sandbox::mojom::Sandbox::kNoSandbox;
+}
+
+BraveExternalProcessImporterClient::BraveExternalProcessImporterClient(
+    base::WeakPtr<ExternalProcessImporterHost> importer_host,
+    const importer::SourceProfile& source_profile,
+    uint16_t items,
+    InProcessImporterBridge* bridge)
+    : ExternalProcessImporterClient(
+          importer_host, source_profile, items, bridge) {}
+
+BraveExternalProcessImporterClient::
+    ~BraveExternalProcessImporterClient() = default;
+
+void BraveExternalProcessImporterClient::Start() {
+  if (!ShouldUseBraveImporter(source_profile_.importer_type)) {
+    ExternalProcessImporterClient::Start();
+    return;
+  }
+
+  AddRef();  // balanced in Cleanup.
+
+  auto options = content::ServiceProcessHost::Options()
+                     .WithDisplayName(IDS_UTILITY_PROCESS_PROFILE_IMPORTER_NAME)
+                     .Pass();
+  content::ServiceProcessHost::Launch(
+      brave_profile_import_.BindNewPipeAndPassReceiver(), std::move(options));
+
+  brave_profile_import_.set_disconnect_handler(
+      base::BindOnce(&ExternalProcessImporterClient::OnProcessCrashed, this));
+
+  base::flat_map<uint32_t, std::string> localized_strings;
+  brave_profile_import_->StartImport(
+      source_profile_, items_, localized_strings,
+      receiver_.BindNewPipeAndPassRemote());
+}
+
+void BraveExternalProcessImporterClient::Cancel() {
+  if (!ShouldUseBraveImporter(source_profile_.importer_type)) {
+    ExternalProcessImporterClient::Cancel();
+    return;
+  }
+
+  if (cancelled_)
+    return;
+
+  cancelled_ = true;
+  brave_profile_import_->CancelImport();
+  CloseMojoHandles();
+  Release();
+}
+
+void BraveExternalProcessImporterClient::CloseMojoHandles() {
+  if (!ShouldUseBraveImporter(source_profile_.importer_type)) {
+    ExternalProcessImporterClient::CloseMojoHandles();
+    return;
+  }
+
+  brave_profile_import_.reset();
+  receiver_.reset();
+}
+
+void BraveExternalProcessImporterClient::OnImportItemFinished(
+    importer::ImportItem import_item) {
+  if (!ShouldUseBraveImporter(source_profile_.importer_type)) {
+    ExternalProcessImporterClient::OnImportItemFinished(import_item);
+    return;
+  }
+
+  if (cancelled_)
+    return;
+
+  bridge_->NotifyItemEnded(import_item);
+  brave_profile_import_->ReportImportItemFinished(import_item);
+}
--- /dev/null
+++ b/chrome/browser/importer/brave_external_process_importer_client.h
@@ -0,0 +1,46 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_CLIENT_H_
+#define BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_CLIENT_H_
+
+#include <string>
+
+#include "base/memory/weak_ptr.h"
+#include "chrome/common/importer/chrome_profile_import.mojom.h"
+#include "chrome/browser/importer/external_process_importer_client.h"
+#include "mojo/public/cpp/bindings/receiver.h"
+#include "mojo/public/cpp/bindings/remote.h"
+
+class BraveExternalProcessImporterClient
+    : public ExternalProcessImporterClient {
+ public:
+  BraveExternalProcessImporterClient(
+      base::WeakPtr<ExternalProcessImporterHost> importer_host,
+      const importer::SourceProfile& source_profile,
+      uint16_t items,
+      InProcessImporterBridge* bridge);
+
+  BraveExternalProcessImporterClient(
+      const BraveExternalProcessImporterClient&) = delete;
+  BraveExternalProcessImporterClient& operator=(
+      const BraveExternalProcessImporterClient&) = delete;
+
+  // ExternalProcessImportClient overrides:
+  void Start() override;
+  void Cancel() override;
+  void CloseMojoHandles() override;
+  void OnImportItemFinished(importer::ImportItem import_item) override;
+
+ protected:
+  ~BraveExternalProcessImporterClient() override;
+
+ private:
+  // Used to start and stop the actual brave importer running in a different
+  // process.
+  mojo::Remote<chrome::mojom::ChromeProfileImport> brave_profile_import_;
+};
+
+#endif  // BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_CLIENT_H_
--- /dev/null
+++ b/chrome/browser/importer/brave_external_process_importer_host.cc
@@ -0,0 +1,185 @@
+/* Copyright (c) 2019 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/brave_external_process_importer_host.h"
+
+#include <memory>
+#include <optional>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/files/file_util.h"
+#include "base/functional/bind.h"
+#include "base/json/json_reader.h"
+#include "base/task/thread_pool.h"
+#include "chrome/common/importer/chrome_importer_utils.h"
+#include "chrome/common/importer/importer_constants.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+#include "chrome/browser/importer/extensions_import_helpers.h"
+#include "chrome/browser/extensions/webstore_install_with_prompt.h"
+#include "chrome/common/extensions/webstore_install_result.h"
+#include "extensions/browser/extension_file_task_runner.h"
+#endif
+
+namespace {
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+
+// Silent installer via websotre w/o any prompt or bubble.
+class WebstoreInstallerForImporting
+    : public extensions::WebstoreInstallWithPrompt {
+ public:
+  using WebstoreInstallWithPrompt::WebstoreInstallWithPrompt;
+
+ private:
+  ~WebstoreInstallerForImporting() override = default;
+
+  std::unique_ptr<ExtensionInstallPrompt::Prompt>
+      CreateInstallPrompt() const override {
+    return nullptr;
+  }
+  bool ShouldShowPostInstallUI() const override { return false; }
+};
+#endif
+
+}  // namespace
+
+BraveExternalProcessImporterHost::BraveExternalProcessImporterHost()
+    : weak_ptr_factory_(this) {}
+BraveExternalProcessImporterHost::~BraveExternalProcessImporterHost() = default;
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+void BraveExternalProcessImporterHost::LaunchExtensionsImport() {
+  base::ThreadPool::PostTaskAndReplyWithResult(
+      FROM_HERE,
+      {base::MayBlock(), base::TaskPriority::USER_VISIBLE,
+       base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+      base::BindOnce(&GetImportableChromeExtensionsList,
+                     source_profile_.source_path),
+      base::BindOnce(
+          &BraveExternalProcessImporterHost::OnGetChromeExtensionsList,
+          weak_ptr_factory_.GetWeakPtr()));
+}
+
+void BraveExternalProcessImporterHost::OnExtensionInstalled(
+    const std::string& extension_id,
+    bool success,
+    const std::string& error,
+    extensions::webstore_install::Result result) {
+  if (success) {
+    return;
+  }
+  VLOG(1) << "Extension " << extension_id << " import failed";
+  extensions::GetExtensionFileTaskRunner()->PostTaskAndReply(
+      FROM_HERE,
+      base::BindOnce(&brave::RemoveExtensionsSettings, profile_->GetPath(),
+                     extension_id),
+      base::BindOnce(
+          &BraveExternalProcessImporterHost::OnExtensionSettingsRemoved,
+          weak_ptr_factory_.GetWeakPtr(), extension_id));
+}
+
+void BraveExternalProcessImporterHost::OnExtensionSettingsRemoved(
+    const std::string& extension_id) {
+  if (settings_removed_callback_for_testing_)
+    settings_removed_callback_for_testing_.Run();
+}
+
+void BraveExternalProcessImporterHost::SetSettingsRemovedCallbackForTesting(
+    base::RepeatingClosure callback) {
+  settings_removed_callback_for_testing_ = std::move(callback);
+}
+
+void BraveExternalProcessImporterHost::InstallExtension(const std::string& id) {
+  if (install_extension_callback_for_testing_) {
+    install_extension_callback_for_testing_.Run(id);
+    return;
+  }
+
+  scoped_refptr<WebstoreInstallerForImporting> installer =
+      new WebstoreInstallerForImporting(
+          id, profile_, /*parent_window=*/nullptr,
+          base::BindOnce(
+              &BraveExternalProcessImporterHost::OnExtensionInstalled,
+              weak_ptr_factory_.GetWeakPtr(), id));
+  installer->BeginInstall();
+}
+
+void BraveExternalProcessImporterHost::ImportExtensions(
+    std::vector<std::string> ids) {
+  for (const auto& id : ids) {
+    InstallExtension(id);
+  }
+
+  if (!ids.empty() && observer_)
+    observer_->ImportItemEnded(importer::EXTENSIONS);
+
+  ExternalProcessImporterHost::NotifyImportEnded();
+}
+
+void BraveExternalProcessImporterHost::OnGetChromeExtensionsList(
+    std::optional<std::vector<std::string>> extensions_list) {
+  if (!extensions_list.has_value()) {
+    ExternalProcessImporterHost::NotifyImportEnded();
+    return;
+  }
+  const auto ids = extensions_list.value();
+  if (ids.empty()) {
+    ExternalProcessImporterHost::NotifyImportEnded();
+    return;
+  }
+  extensions::GetExtensionFileTaskRunner()->PostTaskAndReply(
+      FROM_HERE,
+      base::BindOnce(&brave::ImportStorages, source_profile_.source_path,
+                     profile_->GetPath(), ids),
+      base::BindOnce(&BraveExternalProcessImporterHost::ImportExtensions,
+                     weak_ptr_factory_.GetWeakPtr(), ids));
+}
+
+void BraveExternalProcessImporterHost::NotifyImportEnded() {
+  // If user chooses extension importing, start importing extensions.
+  // and NotifyImportEnded() will be called from OnGetChromeExtensionsList().
+  // Handling extensions importing after finishing all other properties makes
+  // logic simpler.
+  // Don't import if cancelled.
+  if (!cancelled_ && (items_ & importer::EXTENSIONS)) {
+    LaunchExtensionsImport();
+    return;
+  }
+
+  // Otherwise, notifying here and importing is finished.
+  ExternalProcessImporterHost::NotifyImportEnded();
+}
+
+void BraveExternalProcessImporterHost::LaunchImportIfReady() {
+  if (do_not_launch_import_for_testing_)
+    return;
+  ExternalProcessImporterHost::LaunchImportIfReady();
+}
+
+void BraveExternalProcessImporterHost::DoNotLaunchImportForTesting() {
+  do_not_launch_import_for_testing_ = true;
+}
+
+void BraveExternalProcessImporterHost::SetInstallExtensionCallbackForTesting(
+    MockedInstallCallback callback) {
+  install_extension_callback_for_testing_ = std::move(callback);
+}
+
+void BraveExternalProcessImporterHost::NotifyImportEndedForTesting() {
+  ExternalProcessImporterHost::NotifyImportEnded();
+}
+
+importer::ImporterProgressObserver*
+BraveExternalProcessImporterHost::GetObserverForTesting() {
+  return observer_;
+}
+
+#endif
--- /dev/null
+++ b/chrome/browser/importer/brave_external_process_importer_host.h
@@ -0,0 +1,67 @@
+/* Copyright (c) 2019 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_HOST_H_
+#define BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_HOST_H_
+
+#include <optional>
+#include <string>
+#include <vector>
+
+#include "base/gtest_prod_util.h"
+#include "base/memory/weak_ptr.h"
+#include "base/values.h"
+#include "chrome/browser/importer/external_process_importer_host.h"
+#include "chrome/common/extensions/webstore_install_result.h"
+#include "extensions/buildflags/buildflags.h"
+
+class BraveExternalProcessImporterHost : public ExternalProcessImporterHost {
+ public:
+  BraveExternalProcessImporterHost();
+  BraveExternalProcessImporterHost(const BraveExternalProcessImporterHost&) =
+      delete;
+  BraveExternalProcessImporterHost& operator=(
+      const BraveExternalProcessImporterHost&) = delete;
+  using MockedInstallCallback =
+      base::RepeatingCallback<void(const std::string&)>;
+
+ private:
+  friend class ExternalProcessImporterHost;
+  friend class BraveExternalProcessImporterHostUnitTest;
+
+  FRIEND_TEST_ALL_PREFIXES(BraveImporterObserverUnitTest, ImportEvents);
+  FRIEND_TEST_ALL_PREFIXES(BraveImporterObserverUnitTest, DestroyObserverEarly);
+
+  ~BraveExternalProcessImporterHost() override;
+  void OnExtensionInstalled(const std::string& extension_id,
+                            bool success,
+                            const std::string& error,
+                            extensions::webstore_install::Result result);
+  void ImportExtensions(std::vector<std::string> extensions_list);
+  void InstallExtension(const std::string& id);
+  void OnExtensionSettingsRemoved(const std::string& extension_id);
+
+  void DoNotLaunchImportForTesting();
+  void SetInstallExtensionCallbackForTesting(MockedInstallCallback callback);
+  void SetSettingsRemovedCallbackForTesting(base::RepeatingClosure callback);
+  void NotifyImportEndedForTesting();
+  importer::ImporterProgressObserver* GetObserverForTesting();
+
+  // ExternalProcessImporterHost overrides:
+  void NotifyImportEnded() override;
+  void LaunchImportIfReady() override;
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+  void LaunchExtensionsImport();
+  void OnGetChromeExtensionsList(
+      std::optional<std::vector<std::string>> extensions_list);
+#endif
+  bool do_not_launch_import_for_testing_ = false;
+  MockedInstallCallback install_extension_callback_for_testing_;
+  base::RepeatingClosure settings_removed_callback_for_testing_;
+  // Vends weak pointers for the importer to call us back.
+  base::WeakPtrFactory<BraveExternalProcessImporterHost> weak_ptr_factory_;
+};
+
+#endif  // BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_HOST_H_
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_full_disk_access_confirm_dialog_delegate.h
@@ -0,0 +1,44 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_FULL_DISK_ACCESS_CONFIRM_DIALOG_DELEGATE_H_
+#define BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_FULL_DISK_ACCESS_CONFIRM_DIALOG_DELEGATE_H_
+
+#include <string>
+
+#include "base/memory/raw_ptr.h"
+#include "chrome/browser/ui/tab_modal_confirm_dialog_delegate.h"
+
+namespace content {
+class WebContents;
+}  // namespace content
+
+class Browser;
+
+class FullDiskAccessConfirmDialogDelegate
+    : public TabModalConfirmDialogDelegate {
+ public:
+  FullDiskAccessConfirmDialogDelegate(content::WebContents* web_contents,
+                                      Browser* browser);
+  ~FullDiskAccessConfirmDialogDelegate() override;
+
+  FullDiskAccessConfirmDialogDelegate(
+      const FullDiskAccessConfirmDialogDelegate&) = delete;
+  FullDiskAccessConfirmDialogDelegate& operator=(
+      const FullDiskAccessConfirmDialogDelegate&) = delete;
+
+ private:
+  // TabModalConfirmDialogDelegate overrides:
+  std::u16string GetTitle() override;
+  std::u16string GetDialogMessage() override;
+  std::u16string GetLinkText() const override;
+  std::u16string GetAcceptButtonTitle() override;
+  void OnAccepted() override;
+  void OnLinkClicked(WindowOpenDisposition disposition) override;
+
+  raw_ptr<Browser> browser_;
+};
+
+#endif  // BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_FULL_DISK_ACCESS_CONFIRM_DIALOG_DELEGATE_H_
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_full_disk_access_confirm_dialog_delegate_mac.mm
@@ -0,0 +1,61 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/ui/webui/settings/brave_full_disk_access_confirm_dialog_delegate.h"
+
+#import <AppKit/AppKit.h>
+
+#include "base/functional/bind.h"
+#include "base/values.h"
+#include "chrome/browser/importer/external_process_importer_host.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_tabstrip.h"
+#include "chrome/browser/ui/tab_modal_confirm_dialog.h"
+#include "chrome/browser/ui/tab_modal_confirm_dialog_delegate.h"
+#include "chrome/common/importer/importer_data_types.h"
+#include "chrome/grit/generated_resources.h"
+#include "content/public/browser/web_ui.h"
+#include "ui/base/ui_base_types.h"
+#include "url/gurl.h"
+
+FullDiskAccessConfirmDialogDelegate::FullDiskAccessConfirmDialogDelegate(
+    content::WebContents* web_contents,
+    Browser* browser)
+    : TabModalConfirmDialogDelegate(web_contents), browser_(browser) {}
+
+FullDiskAccessConfirmDialogDelegate::~FullDiskAccessConfirmDialogDelegate() =
+    default;
+
+// TODO: figure out l10n
+std::u16string FullDiskAccessConfirmDialogDelegate::GetTitle() {
+  return u"Full Disk Access required";
+}
+
+std::u16string FullDiskAccessConfirmDialogDelegate::GetDialogMessage() {
+  return u"Helium needs Full Disk Access to import your Bookmarks from Safari.";
+}
+
+std::u16string FullDiskAccessConfirmDialogDelegate::GetLinkText() const {
+  return u"Learn how to grant Full Disk Access from your System Preferences.";
+}
+
+std::u16string FullDiskAccessConfirmDialogDelegate::GetAcceptButtonTitle() {
+  return u"Open System Preferences";
+}
+
+void FullDiskAccessConfirmDialogDelegate::OnAccepted() {
+  [[NSWorkspace sharedWorkspace]
+      openURL:[NSURL URLWithString:
+                         @"x-apple.systempreferences:com.apple.preference."
+                         @"security?Privacy_AllFiles"]];  // NOLINT
+}
+
+void FullDiskAccessConfirmDialogDelegate::OnLinkClicked(
+    WindowOpenDisposition disposition) {
+  const int target_index = browser_->tab_strip_model()->active_index() + 1;
+  // Add import help tab right after current settings tab.
+  chrome::AddTabAt(browser_, GURL("https://github.com/imputnet/helium-macos/wiki/Import-data-from-Safari"), target_index,
+                   true /* foreground */);
+}
--- /dev/null
+++ b/chrome/common/importer/chrome_profile_import.mojom
@@ -0,0 +1,26 @@
+// Copyright 2020 The Brave Authors. All rights reserved.
+// This Source Code Form is subject to the terms of the Mozilla Public
+// License, v. 2.0. If a copy of the MPL was not distributed with this file,
+// You can obtain one at http://mozilla.org/MPL/2.0/.
+
+module chrome.mojom;
+
+import "chrome/common/importer/profile_import.mojom";
+import "mojo/public/mojom/base/string16.mojom";
+
+// This interface is used to control the import process.
+interface ChromeProfileImport {
+  // Start the importer. |items| is a bitmask of importer::ImportItem of items
+  // to import.
+  StartImport(
+      chrome.mojom.SourceProfile source_profile,
+      uint16 items,
+      map<uint32, string> localized_strings,
+      pending_remote<chrome.mojom.ProfileImportObserver> observer);
+
+  // Stop the importer.
+  CancelImport();
+
+  // Tell the importer that we're done with one item.
+  ReportImportItemFinished(chrome.mojom.ImportItem item);
+};
--- /dev/null
+++ b/chrome/browser/importer/brave_in_process_importer_bridge.cc
@@ -0,0 +1,10 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/brave_in_process_importer_bridge.h"
+
+#include "chrome/browser/importer/profile_writer.h"
+
+BraveInProcessImporterBridge::~BraveInProcessImporterBridge() = default;
--- /dev/null
+++ b/chrome/browser/importer/brave_in_process_importer_bridge.h
@@ -0,0 +1,25 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_IMPORTER_BRAVE_IN_PROCESS_IMPORTER_BRIDGE_H_
+#define BRAVE_BROWSER_IMPORTER_BRAVE_IN_PROCESS_IMPORTER_BRIDGE_H_
+
+#include <string>
+
+#include "chrome/browser/importer/in_process_importer_bridge.h"
+
+class BraveInProcessImporterBridge : public InProcessImporterBridge {
+ public:
+  using InProcessImporterBridge::InProcessImporterBridge;
+
+  BraveInProcessImporterBridge(const BraveInProcessImporterBridge&) = delete;
+  BraveInProcessImporterBridge operator=(
+      const BraveInProcessImporterBridge&) = delete;
+
+ private:
+  ~BraveInProcessImporterBridge() override;
+};
+
+#endif  // BRAVE_BROWSER_IMPORTER_BRAVE_IN_PROCESS_IMPORTER_BRIDGE_H_
--- /dev/null
+++ b/chrome/browser/importer/extensions_import_helpers.cc
@@ -0,0 +1,96 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/extensions_import_helpers.h"
+
+#include <memory>
+
+#include "base/containers/flat_map.h"
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/task/thread_pool.h"
+#include "chrome/common/importer/importer_constants.h"
+#include "components/value_store/value_store.h"
+#include "components/value_store/value_store_factory.h"
+#include "components/value_store/value_store_factory_impl.h"
+#include "extensions/browser/api/storage/value_store_util.h"
+#include "extensions/browser/extension_file_task_runner.h"
+#include "extensions/common/constants.h"
+
+namespace brave {
+namespace {
+using ExtensionStorageMap =
+    base::flat_map<std::string, std::unique_ptr<value_store::ValueStore>>;
+
+std::vector<std::string> GetChromeExtensionsSettingsList(
+    const base::FilePath& source_profile,
+    std::vector<std::string> extensions_ids) {
+  auto store_factory_source =
+      base::MakeRefCounted<value_store::ValueStoreFactoryImpl>(source_profile);
+  std::vector<std::string> result;
+  for (const auto& id : extensions_ids) {
+    if (!store_factory_source->HasValueStore(
+            base::FilePath(extensions::kLocalExtensionSettingsDirectoryName)
+                .AppendASCII(id)))
+      continue;
+    result.push_back(id);
+  }
+  return result;
+}
+
+ExtensionStorageMap CreateStorages(
+    std::vector<std::string> ids,
+    bool skip_if_exists,
+    scoped_refptr<value_store::ValueStoreFactory> factory) {
+  ExtensionStorageMap storages;
+  for (const auto& id : ids) {
+    if (skip_if_exists &&
+        extensions::value_store_util::HasValueStore(
+            extensions::settings_namespace::LOCAL,
+            extensions::value_store_util::ModelType::EXTENSION, id, factory)) {
+      continue;
+    }
+    storages[id] = extensions::value_store_util::CreateSettingsStore(
+        extensions::settings_namespace::LOCAL,
+        extensions::value_store_util::ModelType::EXTENSION, id, factory);
+  }
+  return storages;
+}
+
+}  // namespace
+
+void ImportStorages(base::FilePath source_profile,
+                    base::FilePath target_profile,
+                    std::vector<std::string> extensions_ids) {
+  DCHECK(
+      extensions::GetExtensionFileTaskRunner()->RunsTasksInCurrentSequence());
+  const auto ids_with_settings =
+      GetChromeExtensionsSettingsList(source_profile, extensions_ids);
+  const auto source_storages = CreateStorages(
+      ids_with_settings, false,
+      base::MakeRefCounted<value_store::ValueStoreFactoryImpl>(source_profile));
+  auto target_storages = CreateStorages(
+      ids_with_settings, true,
+      base::MakeRefCounted<value_store::ValueStoreFactoryImpl>(target_profile));
+  for (const auto& source_store : source_storages) {
+    auto content = source_store.second->Get();
+    if (!content.status().ok() || !target_storages.count(source_store.first))
+      continue;
+    target_storages[source_store.first]->Set(value_store::ValueStore::DEFAULTS,
+                                             content.PassSettings());
+  }
+}
+
+void RemoveExtensionsSettings(base::FilePath target_profile,
+                              const std::string& extension_id) {
+  DCHECK(
+      extensions::GetExtensionFileTaskRunner()->RunsTasksInCurrentSequence());
+  extensions::value_store_util::DeleteValueStore(
+      extensions::settings_namespace::LOCAL,
+      extensions::value_store_util::ModelType::EXTENSION, extension_id,
+      base::MakeRefCounted<value_store::ValueStoreFactoryImpl>(target_profile));
+}
+
+}  // namespace brave
--- /dev/null
+++ b/chrome/browser/importer/extensions_import_helpers.h
@@ -0,0 +1,24 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_IMPORTER_EXTENSIONS_IMPORT_HELPERS_H_
+#define BRAVE_BROWSER_IMPORTER_EXTENSIONS_IMPORT_HELPERS_H_
+
+#include <string>
+#include <vector>
+
+#include "base/files/file_util.h"
+#include "base/values.h"
+
+namespace brave {
+void ImportStorages(base::FilePath source_profile,
+                    base::FilePath target_profile,
+                    std::vector<std::string> extensions_ids);
+
+void RemoveExtensionsSettings(base::FilePath target_profile,
+                              const std::string& extension_id);
+}  // namespace brave
+
+#endif  // BRAVE_BROWSER_IMPORTER_EXTENSIONS_IMPORT_HELPERS_H_
--- /dev/null
+++ b/chrome/utility/importer/brave_profile_import_impl.cc
@@ -0,0 +1,125 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/utility/importer/brave_profile_import_impl.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/command_line.h"
+#include "base/functional/bind.h"
+#include "base/location.h"
+#include "base/memory/ref_counted.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/single_thread_task_runner.h"
+#include "base/threading/thread.h"
+#include "chrome/utility/importer/brave_external_process_importer_bridge.h"
+#include "chrome/utility/importer/chrome_importer.h"
+#include "build/build_config.h"
+#include "chrome/common/importer/importer_type.h"
+#include "chrome/common/importer/profile_import.mojom.h"
+#include "chrome/utility/importer/external_process_importer_bridge.h"
+#include "chrome/utility/importer/importer.h"
+#include "content/public/utility/utility_thread.h"
+#include "mojo/public/cpp/bindings/remote.h"
+#include "mojo/public/cpp/bindings/shared_remote.h"
+
+namespace {
+
+scoped_refptr<Importer> CreateImporterByType(importer::ImporterType type) {
+  switch (type) {
+    case importer::TYPE_CHROME:
+      return new ChromeImporter();
+    case importer::TYPE_EDGE_CHROMIUM:
+      return new ChromeImporter();
+    case importer::TYPE_VIVALDI:
+      return new ChromeImporter();
+    case importer::TYPE_OPERA:
+      return new ChromeImporter();
+    case importer::TYPE_YANDEX:
+      return new ChromeImporter();
+    case importer::TYPE_WHALE:
+      return new ChromeImporter();
+    default:
+      break;
+  }
+  NOTREACHED() << "All handled for supported types above.";
+}
+
+}  // namespace
+
+BraveProfileImportImpl::BraveProfileImportImpl(
+    mojo::PendingReceiver<chrome::mojom::ChromeProfileImport> receiver)
+    : receiver_(this, std::move(receiver)) {}
+
+BraveProfileImportImpl::~BraveProfileImportImpl() = default;
+
+void BraveProfileImportImpl::StartImport(
+    const importer::SourceProfile& source_profile,
+    uint16_t items,
+    const base::flat_map<uint32_t, std::string>& localized_strings,
+    mojo::PendingRemote<chrome::mojom::ProfileImportObserver> observer) {
+  // Signal change to OSCrypt password for importing from Chrome/Chromium
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (source_profile.importer_name.starts_with(u"Chrome")) {
+    command_line->AppendSwitch("import-chrome");
+  } else if (source_profile.importer_type == importer::TYPE_EDGE_CHROMIUM) {
+    command_line->AppendSwitch("import-edge");
+  } else if (source_profile.importer_name.starts_with(u"Chromium")) {
+    command_line->AppendSwitch("import-chromium");
+  } else if (source_profile.importer_type == importer::TYPE_OPERA) {
+    command_line->AppendSwitch("import-opera");
+  } else if (source_profile.importer_type == importer::TYPE_YANDEX) {
+    command_line->AppendSwitch("import-yandex");
+  } else if (source_profile.importer_type == importer::TYPE_WHALE) {
+    command_line->AppendSwitch("import-whale");
+  } else if (source_profile.importer_type == importer::TYPE_VIVALDI) {
+    command_line->AppendSwitch("import-vivaldi");
+  }
+
+  content::UtilityThread::Get()->EnsureBlinkInitialized();
+  importer_ = CreateImporterByType(source_profile.importer_type);
+  if (!importer_.get()) {
+    mojo::Remote<chrome::mojom::ProfileImportObserver>(std::move(observer))
+        ->OnImportFinished(false, "Importer could not be created.");
+    return;
+  }
+
+  items_to_import_ = items;
+
+  // Create worker thread in which importer runs.
+  import_thread_ = std::make_unique<base::Thread>("import_thread");
+#if BUILDFLAG(IS_WIN)
+  import_thread_->init_com_with_mta(false);
+#endif
+  CHECK(import_thread_->Start());
+  bridge_ = new BraveExternalProcessImporterBridge(
+      localized_strings,
+      mojo::SharedRemote<chrome::mojom::ProfileImportObserver>(
+          std::move(observer)));
+  import_thread_->task_runner()->PostTask(
+      FROM_HERE,
+      base::BindOnce(&Importer::StartImport, importer_, source_profile, items,
+                     base::RetainedRef(bridge_)));
+}
+
+void BraveProfileImportImpl::CancelImport() {
+  ImporterCleanup();
+}
+
+void BraveProfileImportImpl::ReportImportItemFinished(
+    importer::ImportItem item) {
+  items_to_import_ ^= item;  // Remove finished item from mask.
+  if (items_to_import_ == 0) {
+    ImporterCleanup();
+  }
+}
+
+void BraveProfileImportImpl::ImporterCleanup() {
+  importer_->Cancel();
+  importer_.reset();
+  bridge_.reset();
+  import_thread_.reset();
+}
--- /dev/null
+++ b/chrome/utility/importer/brave_profile_import_impl.h
@@ -0,0 +1,64 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_UTILITY_IMPORTER_BRAVE_PROFILE_IMPORT_IMPL_H_
+#define BRAVE_UTILITY_IMPORTER_BRAVE_PROFILE_IMPORT_IMPL_H_
+
+#include <memory>
+#include <string>
+
+#include "chrome/common/importer/chrome_profile_import.mojom.h"
+#include "mojo/public/cpp/bindings/pending_receiver.h"
+#include "mojo/public/cpp/bindings/pending_remote.h"
+#include "mojo/public/cpp/bindings/receiver.h"
+
+class BraveExternalProcessImporterBridge;
+class Importer;
+
+namespace base {
+class Thread;
+}  // namespace base
+
+namespace importer {
+struct SourceProfile;
+}  // namespace importer
+
+class BraveProfileImportImpl : public chrome::mojom::ChromeProfileImport {
+ public:
+  explicit BraveProfileImportImpl(
+      mojo::PendingReceiver<chrome::mojom::ChromeProfileImport> receiver);
+  ~BraveProfileImportImpl() override;
+
+  BraveProfileImportImpl(const BraveProfileImportImpl&) = delete;
+  BraveProfileImportImpl& operator=(const BraveProfileImportImpl&) = delete;
+
+ private:
+  // chrome::mojom::ChromeProfileImport overrides:
+  void StartImport(
+      const importer::SourceProfile& source_profile,
+      uint16_t items,
+      const base::flat_map<uint32_t, std::string>& localized_strings,
+      mojo::PendingRemote<chrome::mojom::ProfileImportObserver> observer)
+      override;
+  void CancelImport() override;
+  void ReportImportItemFinished(importer::ImportItem item) override;
+
+  void ImporterCleanup();
+
+  mojo::Receiver<chrome::mojom::ChromeProfileImport> receiver_;
+  std::unique_ptr<base::Thread> import_thread_;
+
+  // Bridge object is passed to importer, so that it can send IPC calls
+  // directly back to the ProfileImportProcessHost.
+  scoped_refptr<BraveExternalProcessImporterBridge> bridge_;
+
+  // A bitmask of importer::ImportItem.
+  uint16_t items_to_import_ = 0;
+
+  // Importer of the appropriate type (Firefox, Safari, IE, etc.)
+  scoped_refptr<Importer> importer_;
+};
+
+#endif  // BRAVE_UTILITY_IMPORTER_BRAVE_PROFILE_IMPORT_IMPL_H_
--- /dev/null
+++ b/chrome/utility/importer/brave_external_process_importer_bridge.cc
@@ -0,0 +1,17 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/utility/importer/brave_external_process_importer_bridge.h"
+
+#include <utility>
+
+BraveExternalProcessImporterBridge::BraveExternalProcessImporterBridge(
+    const base::flat_map<uint32_t, std::string>& localized_strings,
+    mojo::SharedRemote<chrome::mojom::ProfileImportObserver> observer)
+    : ExternalProcessImporterBridge(std::move(localized_strings),
+                                         std::move(observer)) {}
+
+BraveExternalProcessImporterBridge::
+    ~BraveExternalProcessImporterBridge() = default;
--- /dev/null
+++ b/chrome/utility/importer/brave_external_process_importer_bridge.h
@@ -0,0 +1,29 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_UTILITY_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_BRIDGE_H_
+#define BRAVE_UTILITY_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_BRIDGE_H_
+
+#include <string>
+
+#include "chrome/common/importer/chrome_profile_import.mojom.h"
+#include "chrome/utility/importer/external_process_importer_bridge.h"
+
+class BraveExternalProcessImporterBridge : public ExternalProcessImporterBridge {
+ public:
+  BraveExternalProcessImporterBridge(
+      const base::flat_map<uint32_t, std::string>& localized_strings,
+      mojo::SharedRemote<chrome::mojom::ProfileImportObserver> observer);
+
+  BraveExternalProcessImporterBridge(
+      const BraveExternalProcessImporterBridge&) = delete;
+  BraveExternalProcessImporterBridge& operator=(
+      const BraveExternalProcessImporterBridge&) = delete;
+
+ private:
+  ~BraveExternalProcessImporterBridge() override;
+};
+
+#endif  // BRAVE_UTILITY_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_BRIDGE_H_
--- /dev/null
+++ b/chrome/utility/importer/chrome_importer.cc
@@ -0,0 +1,475 @@
+/* Copyright (c) 2019 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include "chrome/utility/importer/chrome_importer.h"
+
+#include <memory>
+#include <optional>
+#include <string>
+#include <utility>
+
+#include "base/files/file_util.h"
+#include "base/json/json_reader.h"
+#include "base/memory/ref_counted.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "build/build_config.h"
+#include "chrome/common/importer/imported_bookmark_entry.h"
+#include "chrome/common/importer/importer_bridge.h"
+#include "chrome/common/importer/importer_data_types.h"
+#include "chrome/common/importer/importer_url_row.h"
+#include "chrome/common/importer/scoped_copy_file.h"
+#include "chrome/grit/generated_resources.h"
+#include "chrome/utility/importer/brave_external_process_importer_bridge.h"
+#include "chrome/utility/importer/favicon_reencode.h"
+#include "components/os_crypt/sync/os_crypt.h"
+#include "components/password_manager/core/browser/password_form.h"
+#include "components/password_manager/core/browser/password_store/login_database.h"
+#include "components/password_manager/core/common/password_manager_pref_names.h"
+#include "components/prefs/json_pref_store.h"
+#include "components/prefs/pref_filter.h"
+#include "components/webdata/common/webdata_constants.h"
+#include "sql/database.h"
+#include "sql/statement.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/page_transition_types.h"
+#include "url/gurl.h"
+
+#if BUILDFLAG(IS_LINUX)
+#include "chrome/grit/branded_strings.h"
+#include "components/os_crypt/sync/key_storage_config_linux.h"
+#endif  // BUILDFLAG(IS_LINUX)
+
+#if BUILDFLAG(IS_WIN)
+#include "base/base64.h"
+#include "base/win/wincrypt_shim.h"
+#endif
+
+using base::Time;
+
+namespace {
+
+// Most of below code is copied from os_crypt_win.cc
+#if BUILDFLAG(IS_WIN)
+// Contains base64 random key encrypted with DPAPI.
+constexpr char kOsCryptEncryptedKeyPrefName[] = "os_crypt.encrypted_key";
+
+// Key prefix for a key encrypted with DPAPI.
+constexpr char kDPAPIKeyPrefix[] = "DPAPI";
+
+bool DecryptStringWithDPAPI(const std::string& ciphertext,
+                            std::string* plaintext) {
+  DATA_BLOB input;
+  input.pbData =
+      const_cast<BYTE*>(reinterpret_cast<const BYTE*>(ciphertext.data()));
+  input.cbData = static_cast<DWORD>(ciphertext.length());
+
+  DATA_BLOB output;
+  BOOL result = CryptUnprotectData(&input, nullptr, nullptr, nullptr, nullptr,
+                                   0, &output);
+  if (!result) {
+    PLOG(ERROR) << "Failed to decrypt";
+    return false;
+  }
+
+  plaintext->assign(reinterpret_cast<char*>(output.pbData), output.cbData);
+  LocalFree(output.pbData);
+  return true;
+}
+
+// Return false if encryption key setting is failed.
+// Fetch chrome's raw encryption key and use it to get chrome's password data.
+bool SetEncryptionKeyForPasswordImporting(
+    const base::FilePath& local_state_path) {
+  std::string local_state_content;
+  base::ReadFileToString(local_state_path, &local_state_content);
+  std::optional<base::Value::Dict> local_state =
+      base::JSONReader::ReadDict(local_state_content);
+  if (!local_state) {
+    return false;
+  }
+
+  if (auto* base64_encrypted_key =
+          local_state->FindStringByDottedPath(kOsCryptEncryptedKeyPrefName)) {
+    std::string encrypted_key_with_header;
+
+    base::Base64Decode(*base64_encrypted_key, &encrypted_key_with_header);
+
+    if (!encrypted_key_with_header.starts_with(kDPAPIKeyPrefix)) {
+      return false;
+    }
+    std::string encrypted_key =
+        encrypted_key_with_header.substr(sizeof(kDPAPIKeyPrefix) - 1);
+    std::string key;
+    // This DPAPI decryption can fail if the user's password has been reset
+    // by an Administrator.
+    if (DecryptStringWithDPAPI(encrypted_key, &key)) {
+      OSCrypt::SetRawEncryptionKey(key);
+      return true;
+    }
+  }
+  return false;
+}
+#endif
+
+bool SetEncryptionKey(const base::FilePath& source_path) {
+#if BUILDFLAG(IS_LINUX)
+  // Set up crypt config.
+  std::unique_ptr<os_crypt::Config> config(new os_crypt::Config());
+  config->product_name = l10n_util::GetStringUTF8(IDS_PRODUCT_NAME);
+  config->should_use_preference = false;
+  config->user_data_path = source_path;
+  OSCrypt::SetConfig(std::move(config));
+  return true;
+#elif BUILDFLAG(IS_WIN)
+  base::FilePath local_state_path = source_path.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("Local State")));
+  if (!base::PathExists(local_state_path))
+    return false;
+  if (!SetEncryptionKeyForPasswordImporting(local_state_path))
+    return false;
+  return true;
+#else
+  return true;
+#endif
+}
+
+bool PasswordFormToImportedPasswordForm(
+    const password_manager::PasswordForm& form,
+    importer::ImportedPasswordForm& imported_form) {
+  if (form.scheme != password_manager::PasswordForm::Scheme::kHtml &&
+      form.scheme != password_manager::PasswordForm::Scheme::kBasic) {
+    return false;
+  }
+
+  if (form.scheme == password_manager::PasswordForm::Scheme::kHtml) {
+    imported_form.scheme = importer::ImportedPasswordForm::Scheme::kHtml;
+  } else {
+    imported_form.scheme = importer::ImportedPasswordForm::Scheme::kBasic;
+  }
+
+  imported_form.signon_realm = form.signon_realm;
+  imported_form.url = form.url;
+  imported_form.action = form.action;
+  imported_form.username_element = form.username_element;
+  imported_form.username_value = form.username_value;
+  imported_form.password_element = form.password_element;
+  imported_form.password_value = form.password_value;
+  imported_form.blocked_by_user = form.blocked_by_user;
+  return true;
+}
+
+}  // namespace
+
+ChromeImporter::ChromeImporter() = default;
+
+ChromeImporter::~ChromeImporter() = default;
+
+void ChromeImporter::StartImport(const importer::SourceProfile& source_profile,
+                                 uint16_t items,
+                                 ImporterBridge* bridge) {
+  bridge_ = bridge;
+  source_path_ = source_profile.source_path;
+  importer_name_ = source_profile.importer_name;
+  // The order here is important!
+  bridge_->NotifyStarted();
+
+  if ((items & importer::HISTORY) && !cancelled()) {
+    bridge_->NotifyItemStarted(importer::HISTORY);
+    ImportHistory();
+    bridge_->NotifyItemEnded(importer::HISTORY);
+  }
+
+  if ((items & importer::FAVORITES) && !cancelled()) {
+    bridge_->NotifyItemStarted(importer::FAVORITES);
+    ImportBookmarks();
+    bridge_->NotifyItemEnded(importer::FAVORITES);
+  }
+
+#if BUILDFLAG(IS_WIN)
+  auto source_path = source_profile.importer_type == importer::TYPE_OPERA
+                         ? source_path_
+                         : source_path_.DirName();
+#else
+  auto source_path = source_path_;
+#endif
+  const bool set_encryption_key = SetEncryptionKey(source_path);
+  if ((items & importer::PASSWORDS) && !cancelled() && set_encryption_key) {
+    bridge_->NotifyItemStarted(importer::PASSWORDS);
+    ImportPasswords(base::FilePath(FILE_PATH_LITERAL("Login Data")));
+    ImportPasswords(
+        base::FilePath(FILE_PATH_LITERAL("Login Data For Account")));
+    bridge_->NotifyItemEnded(importer::PASSWORDS);
+  }
+
+  bridge_->NotifyEnded();
+}
+
+void ChromeImporter::ImportHistory() {
+  base::FilePath history_path = source_path_.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("History")));
+  if (!base::PathExists(history_path))
+    return;
+
+  ScopedCopyFile copy_history_file(history_path);
+  if (!copy_history_file.copy_success())
+    return;
+
+  sql::Database db(sql::Database::Tag("History"));
+  if (!db.Open(copy_history_file.copied_file_path())) {
+    return;
+  }
+
+  const char query[] =
+      "SELECT u.url, u.title, v.visit_time, u.typed_count, u.visit_count "
+      "FROM urls u JOIN visits v ON u.id = v.url "
+      "WHERE hidden = 0 "
+      "AND (transition & ?) != 0 "              // CHAIN_END
+      "AND (transition & ?) NOT IN (?, ?, ?)";  // No SUBFRAME or
+                                                // KEYWORD_GENERATED
+
+  sql::Statement s(db.GetUniqueStatement(query));
+  s.BindInt64(0, ui::PAGE_TRANSITION_CHAIN_END);
+  s.BindInt64(1, ui::PAGE_TRANSITION_CORE_MASK);
+  s.BindInt64(2, ui::PAGE_TRANSITION_AUTO_SUBFRAME);
+  s.BindInt64(3, ui::PAGE_TRANSITION_MANUAL_SUBFRAME);
+  s.BindInt64(4, ui::PAGE_TRANSITION_KEYWORD_GENERATED);
+
+  std::vector<ImporterURLRow> rows;
+  while (s.Step() && !cancelled()) {
+    GURL url(s.ColumnString(0));
+
+    ImporterURLRow row(url);
+    row.title = s.ColumnString16(1);
+    row.last_visit = base::Time::FromSecondsSinceUnixEpoch(
+        chromeTimeToDouble((s.ColumnInt64(2))));
+    row.hidden = false;
+    row.typed_count = s.ColumnInt(3);
+    row.visit_count = s.ColumnInt(4);
+
+    rows.push_back(row);
+  }
+
+  if (!rows.empty() && !cancelled())
+    bridge_->SetHistoryItems(rows, importer::VISIT_SOURCE_CHROME_IMPORTED);
+}
+
+void ChromeImporter::ImportBookmarks() {
+  std::string bookmarks_content;
+  base::FilePath bookmarks_path = source_path_.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("Bookmarks")));
+  ScopedCopyFile copy_bookmark_file(bookmarks_path);
+  if (!copy_bookmark_file.copy_success())
+    return;
+
+  base::ReadFileToString(copy_bookmark_file.copied_file_path(),
+                         &bookmarks_content);
+  std::optional<base::Value::Dict> bookmark_dict =
+      base::JSONReader::ReadDict(bookmarks_content);
+  if (!bookmark_dict)
+    return;
+
+  std::vector<ImportedBookmarkEntry> bookmarks;
+  const base::Value::Dict* roots = bookmark_dict->FindDict("roots");
+  if (roots) {
+    // Importing bookmark bar items
+    const base::Value::Dict* bookmark_bar = roots->FindDict("bookmark_bar");
+    if (bookmark_bar) {
+      std::vector<std::u16string> path;
+      const auto* name = bookmark_bar->FindString("name");
+
+      path.push_back(base::UTF8ToUTF16(name ? *name : std::string()));
+      RecursiveReadBookmarksFolder(bookmark_bar, path, true, &bookmarks);
+    }
+    // Importing other items
+    const base::Value::Dict* other = roots->FindDict("other");
+    if (other) {
+      std::vector<std::u16string> path;
+      const auto* name = other->FindString("name");
+
+      path.push_back(base::UTF8ToUTF16(name ? *name : std::string()));
+      RecursiveReadBookmarksFolder(other, path, false, &bookmarks);
+    }
+  }
+  // Write into profile.
+  if (!bookmarks.empty() && !cancelled()) {
+    bridge_->AddBookmarks(
+        bookmarks, l10n_util::GetStringFUTF16(IDS_IMPORTED_FROM_BOOKMARK_FOLDER,
+                                              importer_name_));
+  }
+
+  // Import favicons.
+  base::FilePath favicons_path = source_path_.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("Favicons")));
+  if (!base::PathExists(favicons_path))
+    return;
+
+  ScopedCopyFile copy_favicon_file(favicons_path);
+  if (!copy_favicon_file.copy_success())
+    return;
+
+  sql::Database db(sql::Database::Tag("Favicons"));
+  if (!db.Open(copy_favicon_file.copied_file_path()))
+    return;
+
+  FaviconMap favicon_map;
+  ImportFaviconURLs(&db, &favicon_map);
+  // Write favicons into profile.
+  if (!favicon_map.empty() && !cancelled()) {
+    favicon_base::FaviconUsageDataList favicons;
+    LoadFaviconData(&db, favicon_map, &favicons);
+    bridge_->SetFavicons(favicons);
+  }
+}
+
+void ChromeImporter::ImportFaviconURLs(sql::Database* db,
+                                       FaviconMap* favicon_map) {
+  const char query[] = "SELECT icon_id, page_url FROM icon_mapping;";
+  sql::Statement s(db->GetUniqueStatement(query));
+
+  while (s.Step() && !cancelled()) {
+    int64_t icon_id = s.ColumnInt64(0);
+    GURL url = GURL(s.ColumnString(1));
+    (*favicon_map)[icon_id].insert(url);
+  }
+}
+
+void ChromeImporter::LoadFaviconData(
+    sql::Database* db,
+    const FaviconMap& favicon_map,
+    favicon_base::FaviconUsageDataList* favicons) {
+  const char query[] =
+      "SELECT f.url, fb.image_data "
+      "FROM favicons f "
+      "JOIN favicon_bitmaps fb "
+      "ON f.id = fb.icon_id "
+      "WHERE f.id = ?;";
+  sql::Statement s(db->GetUniqueStatement(query));
+
+  if (!s.is_valid())
+    return;
+
+  for (const auto& entry : favicon_map) {
+    s.BindInt64(0, entry.first);
+    if (s.Step()) {
+      favicon_base::FaviconUsageData usage;
+
+      usage.favicon_url = GURL(s.ColumnString(0));
+      if (!usage.favicon_url.is_valid())
+        continue;  // Don't bother importing favicons with invalid URLs.
+
+      std::vector<uint8_t> data;
+      s.ColumnBlobAsVector(1, &data);
+      if (data.empty())
+        continue;  // Data definitely invalid.
+
+      auto decoded_data = importer::ReencodeFavicon(base::span(data));
+      if (!decoded_data) {
+        continue;  // Unable to decode.
+      }
+
+      usage.urls = entry.second;
+      usage.png_data = std::move(decoded_data).value();
+      favicons->push_back(usage);
+    }
+    s.Reset(true);
+  }
+}
+
+void ChromeImporter::RecursiveReadBookmarksFolder(
+    const base::Value::Dict* folder,
+    const std::vector<std::u16string>& parent_path,
+    bool is_in_toolbar,
+    std::vector<ImportedBookmarkEntry>* bookmarks) {
+  const base::Value::List* children = folder->FindList("children");
+  if (children) {
+    for (const auto& value : *children) {
+      const base::Value::Dict* dict = value.GetIfDict();
+      if (!dict)
+        continue;
+      const auto* date_added = dict->FindString("date_added");
+      const auto* name_found = dict->FindString("name");
+      auto name = base::UTF8ToUTF16(name_found ? *name_found : std::string());
+      const auto* type = dict->FindString("type");
+      const auto* url = dict->FindString("url");
+      ImportedBookmarkEntry entry;
+      if (type && *type == "folder") {
+        // Folders are added implicitly on adding children, so we only
+        // explicitly add empty folders.
+        const base::Value::List* inner_children = dict->FindList("children");
+        if (inner_children && inner_children->empty()) {
+          entry.in_toolbar = is_in_toolbar;
+          entry.is_folder = true;
+          entry.url = GURL();
+          entry.path = parent_path;
+          entry.title = name;
+          entry.creation_time = base::Time::FromSecondsSinceUnixEpoch(
+              chromeTimeToDouble(std::stoll(*date_added)));
+          bookmarks->push_back(entry);
+        }
+
+        std::vector<std::u16string> path = parent_path;
+        path.push_back(name);
+        RecursiveReadBookmarksFolder(dict, path, is_in_toolbar, bookmarks);
+      } else if (type && *type == "url") {
+        entry.in_toolbar = is_in_toolbar;
+        entry.is_folder = false;
+        entry.url = GURL(*url);
+        entry.path = parent_path;
+        entry.title = name;
+        entry.creation_time = base::Time::FromSecondsSinceUnixEpoch(
+            chromeTimeToDouble(std::stoll(*date_added)));
+        bookmarks->push_back(entry);
+      }
+    }
+  }
+}
+
+double ChromeImporter::chromeTimeToDouble(int64_t time) {
+  return ((time * 10 - 0x19DB1DED53E8000) / 10000) / 1000;
+}
+
+void ChromeImporter::ImportPasswords(
+    const base::FilePath& passwords_file_name) {
+  base::FilePath passwords_path = source_path_.Append(passwords_file_name);
+
+  if (!base::PathExists(passwords_path))
+    return;
+
+  ScopedCopyFile copy_password_file(passwords_path);
+  if (!copy_password_file.copy_success())
+    return;
+
+  password_manager::LoginDatabase database(
+      copy_password_file.copied_file_path(),
+      password_manager::IsAccountStore(false));
+  if (!database.Init(
+          /*on_undecryptable_passwords_removed=*/base::NullCallback(),
+          /*encryptor=*/nullptr)) {
+    LOG(ERROR) << "LoginDatabase Init() failed";
+    return;
+  }
+
+  std::vector<password_manager::PasswordForm> forms;
+  bool success = database.GetAutofillableLogins(&forms);
+  if (success) {
+    for (auto& entry : forms) {
+      importer::ImportedPasswordForm form;
+      if (PasswordFormToImportedPasswordForm(entry, form)) {
+        bridge_->SetPasswordForm(form);
+      }
+    }
+  }
+  std::vector<password_manager::PasswordForm> blocklist;
+  success = database.GetBlocklistLogins(&blocklist);
+  if (success) {
+    for (auto& entry : blocklist) {
+      importer::ImportedPasswordForm form;
+      if (PasswordFormToImportedPasswordForm(entry, form)) {
+        bridge_->SetPasswordForm(form);
+      }
+    }
+  }
+}
--- /dev/null
+++ b/chrome/utility/importer/chrome_importer.h
@@ -0,0 +1,75 @@
+/* Copyright (c) 2019 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_UTILITY_IMPORTER_CHROME_IMPORTER_H_
+#define BRAVE_UTILITY_IMPORTER_CHROME_IMPORTER_H_
+
+#include <stdint.h>
+
+#include <map>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/files/file_path.h"
+#include "base/nix/xdg_util.h"
+#include "base/values.h"
+#include "build/build_config.h"
+#include "chrome/utility/importer/importer.h"
+#include "components/favicon_base/favicon_usage_data.h"
+
+struct ImportedBookmarkEntry;
+
+namespace sql {
+class Database;
+}
+
+class ChromeImporter : public Importer {
+ public:
+  ChromeImporter();
+  ChromeImporter(const ChromeImporter&) = delete;
+  ChromeImporter& operator=(const ChromeImporter&) = delete;
+
+  // Importer:
+  void StartImport(const importer::SourceProfile& source_profile,
+                   uint16_t items,
+                   ImporterBridge* bridge) override;
+
+ protected:
+  ~ChromeImporter() override;
+
+  void ImportBookmarks();
+  void ImportHistory();
+  void ImportPasswords(const base::FilePath& passwords_file_name);
+
+  double chromeTimeToDouble(int64_t time);
+
+  base::FilePath source_path_;
+
+ private:
+  // Multiple URLs can share the same favicon; this is a map
+  // of URLs -> IconIDs that we load as a temporary step before
+  // actually loading the icons.
+  typedef std::map<int64_t, std::set<GURL>> FaviconMap;
+
+  // Loads the urls associated with the favicons into favicon_map;
+  void ImportFaviconURLs(sql::Database* db, FaviconMap* favicon_map);
+
+  // Loads and reencodes the individual favicons.
+  void LoadFaviconData(sql::Database* db,
+                       const FaviconMap& favicon_map,
+                       favicon_base::FaviconUsageDataList* favicons);
+
+  void RecursiveReadBookmarksFolder(
+      const base::Value::Dict* folder,
+      const std::vector<std::u16string>& parent_path,
+      bool is_in_toolbar,
+      std::vector<ImportedBookmarkEntry>* bookmarks);
+
+  std::u16string importer_name_;
+};
+
+#endif  // BRAVE_UTILITY_IMPORTER_CHROME_IMPORTER_H_
--- a/chrome/app/generated_resources.grd
+++ b/chrome/app/generated_resources.grd
@@ -10755,6 +10755,9 @@ Check your passwords anytime in <ph name
             Microsoft Edge
           </message>
         </if>
+        <message name="IDS_IMPORTED_FROM_BOOKMARK_FOLDER" desc="Name for bookmark panel folder imported from another browser">
+          Imported from <ph name="BROWSER_NAME">$1<ex>Chrome</ex></ph>.
+        </message>
         <message name="IDS_IMPORT_FROM_FIREFOX" desc="browser combo box: Mozilla Firefox">
           Mozilla Firefox
         </message>
